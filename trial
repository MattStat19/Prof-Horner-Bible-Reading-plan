const STORAGE_KEY = "hornerPlanStateV1";
const TEXT_CACHE_KEY = "hornerTextCacheV1";
const DEFAULT_TRANSLATION = "WEB";
const TRANSLATION_OPTIONS = ["WEB", "KJV", "ESV", "NIV", "NKJV", "NASB"];
const INLINE_TEXT_TRANSLATION_MAP = {
  WEB: "web",
  KJV: "kjv",
};

const BOOK_CHAPTERS = {
  Genesis: 50,
  Exodus: 40,
  Leviticus: 27,
  Numbers: 36,
  Deuteronomy: 34,
  Joshua: 24,
  Judges: 21,
  Ruth: 4,
  "1 Samuel": 31,
  "2 Samuel": 24,
  "1 Kings": 22,
  "2 Kings": 25,
  "1 Chronicles": 29,
  "2 Chronicles": 36,
  Ezra: 10,
  Nehemiah: 13,
  Esther: 10,
  Job: 42,
  Psalms: 150,
  Proverbs: 31,
  Ecclesiastes: 12,
  "Song of Solomon": 8,
  Isaiah: 66,
  Jeremiah: 52,
  Lamentations: 5,
  Ezekiel: 48,
  Daniel: 12,
  Hosea: 14,
  Joel: 3,
  Amos: 9,
  Obadiah: 1,
  Jonah: 4,
  Micah: 7,
  Nahum: 3,
  Habakkuk: 3,
  Zephaniah: 3,
  Haggai: 2,
  Zechariah: 14,
  Malachi: 4,
  Matthew: 28,
  Mark: 16,
  Luke: 24,
  John: 21,
  Acts: 28,
  Romans: 16,
  "1 Corinthians": 16,
  "2 Corinthians": 13,
  Galatians: 6,
  Ephesians: 6,
  Philippians: 4,
  Colossians: 4,
  "1 Thessalonians": 5,
  "2 Thessalonians": 3,
  "1 Timothy": 6,
  "2 Timothy": 4,
  Titus: 3,
  Philemon: 1,
  Hebrews: 13,
  James: 5,
  "1 Peter": 5,
  "2 Peter": 3,
  "1 John": 5,
  "2 John": 1,
  "3 John": 1,
  Jude: 1,
  Revelation: 22,
};

const HORNER_TRACKS = [
  {
    id: "track-1",
    title: "Track 1: Matthew to John",
    books: ["Matthew", "Mark", "Luke", "John"],
  },
  {
    id: "track-2",
    title: "Track 2: Genesis to Deuteronomy",
    books: ["Genesis", "Exodus", "Leviticus", "Numbers", "Deuteronomy"],
  },
  {
    id: "track-3",
    title: "Track 3: Romans to Hebrews",
    books: [
      "Romans",
      "1 Corinthians",
      "2 Corinthians",
      "Galatians",
      "Ephesians",
      "Philippians",
      "Colossians",
      "Hebrews",
    ],
  },
  {
    id: "track-4",
    title: "Track 4: 1 Thessalonians to Revelation",
    books: [
      "1 Thessalonians",
      "2 Thessalonians",
      "1 Timothy",
      "2 Timothy",
      "Titus",
      "Philemon",
      "James",
      "1 Peter",
      "2 Peter",
      "1 John",
      "2 John",
      "3 John",
      "Jude",
      "Revelation",
    ],
  },
  {
    id: "track-5",
    title: "Track 5: Job to Song of Solomon",
    books: ["Job", "Ecclesiastes", "Song of Solomon"],
  },
  { id: "track-6", title: "Track 6: Psalms", books: ["Psalms"] },
  { id: "track-7", title: "Track 7: Proverbs", books: ["Proverbs"] },
  {
    id: "track-8",
    title: "Track 8: Joshua to Esther",
    books: [
      "Joshua",
      "Judges",
      "Ruth",
      "1 Samuel",
      "2 Samuel",
      "1 Kings",
      "2 Kings",
      "1 Chronicles",
      "2 Chronicles",
      "Ezra",
      "Nehemiah",
      "Esther",
    ],
  },
  {
    id: "track-9",
    title: "Track 9: Isaiah to Malachi",
    books: [
      "Isaiah",
      "Jeremiah",
      "Lamentations",
      "Ezekiel",
      "Daniel",
      "Hosea",
      "Joel",
      "Amos",
      "Obadiah",
      "Jonah",
      "Micah",
      "Nahum",
      "Habakkuk",
      "Zephaniah",
      "Haggai",
      "Zechariah",
      "Malachi",
    ],
  },
  { id: "track-10", title: "Track 10: Acts", books: ["Acts"] },
];

const ui = {
  dayLabel: document.getElementById("dayLabel"),
  progressLabel: document.getElementById("progressLabel"),
  tracksGrid: document.getElementById("tracksGrid"),
  trackTemplate: document.getElementById("trackTemplate"),
  advanceDayBtn: document.getElementById("advanceDayBtn"),
  checkAllBtn: document.getElementById("checkAllBtn"),
  resetBtn: document.getElementById("resetBtn"),
  translationSelect: document.getElementById("translationSelect"),
  inlineTextHint: document.getElementById("inlineTextHint"),
};

let state = loadState();
let chapterTextCache = loadTextCache();
const expandedTrackIds = new Set();
const pendingTextRequests = new Set();
const textErrors = {};

render();
bindEvents();

function createInitialState() {
  return {
    day: 1,
    translation: DEFAULT_TRANSLATION,
    completedTrackIds: [],
    tracks: HORNER_TRACKS.map(() => ({
      bookIndex: 0,
      chapter: 1,
      loops: 0,
    })),
  };
}

function loadState() {
  const fallback = createInitialState();
  const raw = localStorage.getItem(STORAGE_KEY);

  if (!raw) {
    return fallback;
  }

  try {
    const parsed = JSON.parse(raw);

    if (!Array.isArray(parsed.tracks) || parsed.tracks.length !== HORNER_TRACKS.length) {
      return fallback;
    }

    const tracks = parsed.tracks.map((track, index) => sanitizeTrack(track, index));
    const completedTrackIds = Array.isArray(parsed.completedTrackIds)
      ? parsed.completedTrackIds.filter((id) => HORNER_TRACKS.some((track) => track.id === id))
      : [];

    return {
      day: Number.isInteger(parsed.day) && parsed.day > 0 ? parsed.day : 1,
      translation: TRANSLATION_OPTIONS.includes(parsed.translation)
        ? parsed.translation
        : DEFAULT_TRANSLATION,
      completedTrackIds,
      tracks,
    };
  } catch (_error) {
    return fallback;
  }
}

function loadTextCache() {
  const raw = localStorage.getItem(TEXT_CACHE_KEY);

  if (!raw) {
    return {};
  }

  try {
    const parsed = JSON.parse(raw);
    return parsed && typeof parsed === "object" ? parsed : {};
  } catch (_error) {
    return {};
  }
}

function saveTextCache() {
  localStorage.setItem(TEXT_CACHE_KEY, JSON.stringify(chapterTextCache));
}

function sanitizeTrack(track, index) {
  const safeTrack = track && typeof track === "object" ? track : {};
  const definition = HORNER_TRACKS[index];
  const maxBookIndex = definition.books.length - 1;
  const safeBookIndex =
    Number.isInteger(safeTrack.bookIndex) &&
    safeTrack.bookIndex >= 0 &&
    safeTrack.bookIndex <= maxBookIndex
      ? safeTrack.bookIndex
      : 0;
  const currentBook = definition.books[safeBookIndex];
  const maxChapter = BOOK_CHAPTERS[currentBook];
  const safeChapter =
    Number.isInteger(safeTrack.chapter) && safeTrack.chapter >= 1 && safeTrack.chapter <= maxChapter
      ? safeTrack.chapter
      : 1;

  return {
    bookIndex: safeBookIndex,
    chapter: safeChapter,
    loops: Number.isInteger(safeTrack.loops) && safeTrack.loops >= 0 ? safeTrack.loops : 0,
  };
}

function saveState() {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
}

function bindEvents() {
  ui.advanceDayBtn.addEventListener("click", advanceDay);
  ui.checkAllBtn.addEventListener("click", markAllChecked);
  ui.resetBtn.addEventListener("click", resetPlan);
  ui.translationSelect.addEventListener("change", (event) => {
    state.translation = event.target.value;
    saveState();
    render();
  });
}

function render() {
  ui.dayLabel.textContent = `Day ${state.day}`;
  ui.progressLabel.textContent = `${state.completedTrackIds.length}/${HORNER_TRACKS.length} tracks checked for today`;
  ui.translationSelect.value = state.translation;
  ui.inlineTextHint.textContent = getInlineTextApiCode(state.translation)
    ? "Inline full text is available for WEB and KJV."
    : `Inline full text is unavailable for ${state.translation}. Switch to WEB or KJV.`;

  ui.tracksGrid.textContent = "";

  HORNER_TRACKS.forEach((trackDefinition, index) => {
    const trackState = state.tracks[index];
    const currentBook = trackDefinition.books[trackState.bookIndex];
    const passage = `${currentBook} ${trackState.chapter}`;
    const isChecked = state.completedTrackIds.includes(trackDefinition.id);
    const isExpanded = expandedTrackIds.has(trackDefinition.id);
    const cacheKey = getTextCacheKey(passage, state.translation);
    const hasInlineSupport = Boolean(getInlineTextApiCode(state.translation));
    const isLoading = pendingTextRequests.has(cacheKey);
    const cachedText = chapterTextCache[cacheKey];
    const errorMessage = textErrors[cacheKey];

    const node = ui.trackTemplate.content.firstElementChild.cloneNode(true);
    node.style.animationDelay = `${index * 25}ms`;
    node.classList.toggle("checked", isChecked);

    node.querySelector(".track-title").textContent = trackDefinition.title;
    node.querySelector(".track-loop").textContent =
      trackState.loops > 0 ? `Loop ${trackState.loops + 1}` : "Loop 1";
    node.querySelector(".track-passage").textContent = passage;
    node.querySelector(".track-books").textContent = trackDefinition.books.join(", ");

    const checkbox = node.querySelector(".track-check");
    checkbox.checked = isChecked;
    checkbox.addEventListener("change", () => {
      toggleTrackChecked(trackDefinition.id, checkbox.checked);
    });

    const inlineTextButton = node.querySelector(".inline-text-btn");
    inlineTextButton.disabled = !hasInlineSupport || isLoading;
    inlineTextButton.textContent = !hasInlineSupport
      ? "No Inline Text"
      : isLoading
        ? "Loading..."
        : isExpanded
          ? "Hide Text"
          : cachedText
            ? "Show Text"
            : "Load Text";
    inlineTextButton.addEventListener("click", () => {
      toggleInlineText(trackDefinition.id, passage);
    });

    const inlineTextWrap = node.querySelector(".inline-text-wrap");
    const inlineTextStatus = node.querySelector(".inline-text-status");
    const inlineTextContent = node.querySelector(".inline-text-content");

    inlineTextWrap.hidden = !isExpanded;

    if (isExpanded) {
      if (!hasInlineSupport) {
        inlineTextStatus.textContent = "This translation cannot be shown inline.";
        inlineTextContent.textContent = "Choose WEB or KJV for full chapter text in-app.";
      } else if (isLoading) {
        inlineTextStatus.textContent = `Loading ${passage} (${state.translation})...`;
        inlineTextContent.textContent = "";
      } else if (errorMessage) {
        inlineTextStatus.textContent = "Unable to load chapter text.";
        inlineTextContent.textContent = errorMessage;
      } else if (cachedText) {
        inlineTextStatus.textContent = `${passage} (${state.translation})`;
        inlineTextContent.textContent = cachedText;
      } else {
        inlineTextStatus.textContent = `Loading ${passage} (${state.translation})...`;
        inlineTextContent.textContent = "";
        void ensureInlineText(passage);
      }
    }

    const openLink = node.querySelector(".open-link");
    openLink.href = buildBibleGatewayUrl(passage, state.translation);
    openLink.textContent = `Open (${state.translation})`;

    ui.tracksGrid.appendChild(node);
  });
}

function toggleTrackChecked(trackId, checked) {
  const set = new Set(state.completedTrackIds);

  if (checked) {
    set.add(trackId);
  } else {
    set.delete(trackId);
  }

  state.completedTrackIds = [...set];
  saveState();
  render();
}

function markAllChecked() {
  state.completedTrackIds = HORNER_TRACKS.map((track) => track.id);
  saveState();
  render();
}

function advanceDay() {
  if (state.completedTrackIds.length !== HORNER_TRACKS.length) {
    const proceed = window.confirm(
      "Some tracks are not checked yet. Advance anyway and move to the next day?"
    );
    if (!proceed) {
      return;
    }
  }

  state.tracks = state.tracks.map((track, index) => getNextTrack(track, HORNER_TRACKS[index]));
  state.day += 1;
  state.completedTrackIds = [];
  saveState();
  render();
}

function getNextTrack(trackState, trackDefinition) {
  const currentBook = trackDefinition.books[trackState.bookIndex];
  const maxChapter = BOOK_CHAPTERS[currentBook];

  if (trackState.chapter < maxChapter) {
    return {
      ...trackState,
      chapter: trackState.chapter + 1,
    };
  }

  if (trackState.bookIndex < trackDefinition.books.length - 1) {
    return {
      ...trackState,
      bookIndex: trackState.bookIndex + 1,
      chapter: 1,
    };
  }

  return {
    bookIndex: 0,
    chapter: 1,
    loops: trackState.loops + 1,
  };
}

function resetPlan() {
  const shouldReset = window.confirm("Reset all progress and return every track to chapter 1?");
  if (!shouldReset) {
    return;
  }

  const selectedTranslation = state.translation;
  state = createInitialState();
  state.translation = selectedTranslation;
  expandedTrackIds.clear();
  saveState();
  render();
}

function getInlineTextApiCode(translation) {
  return INLINE_TEXT_TRANSLATION_MAP[translation] || null;
}

function getTextCacheKey(reference, translation) {
  return `${translation}:${reference}`;
}

async function ensureInlineText(reference) {
  const apiCode = getInlineTextApiCode(state.translation);
  if (!apiCode) {
    return;
  }

  const cacheKey = getTextCacheKey(reference, state.translation);
  if (chapterTextCache[cacheKey] || pendingTextRequests.has(cacheKey)) {
    return;
  }

  pendingTextRequests.add(cacheKey);
  delete textErrors[cacheKey];
  render();

  try {
    const encodedReference = encodeURIComponent(reference);
    const response = await fetch(`https://bible-api.com/${encodedReference}?translation=${apiCode}`);

    if (!response.ok) {
      throw new Error(`Request failed with status ${response.status}.`);
    }

    const payload = await response.json();
    const chapterText = formatChapterText(payload);

    if (!chapterText) {
      throw new Error("No chapter text returned.");
    }

    chapterTextCache[cacheKey] = chapterText;
    saveTextCache();
  } catch (error) {
    textErrors[cacheKey] = error instanceof Error ? error.message : "Unexpected error.";
  } finally {
    pendingTextRequests.delete(cacheKey);
    render();
  }
}

function toggleInlineText(trackId, passage) {
  if (expandedTrackIds.has(trackId)) {
    expandedTrackIds.delete(trackId);
    render();
    return;
  }

  expandedTrackIds.add(trackId);
  void ensureInlineText(passage);
  render();
}

function formatChapterText(payload) {
  if (Array.isArray(payload.verses) && payload.verses.length > 0) {
    return payload.verses
      .map((verse) => `${verse.verse}. ${normalizeVerseText(verse.text || "")}`)
      .join("\n");
  }

  if (typeof payload.text === "string") {
    return payload.text.trim();
  }

  return "";
}

function normalizeVerseText(text) {
  return text.replace(/\s+/g, " ").trim();
}

function buildBibleGatewayUrl(reference, translation) {
  const encodedReference = encodeURIComponent(reference);
  const encodedVersion = encodeURIComponent(translation);
  return `https://www.biblegateway.com/passage/?search=${encodedReference}&version=${encodedVersion}`;
}
